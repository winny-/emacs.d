#+title: Literate Programming =init.el=
#+startup: indent content
#+property: header-args :results silent

* Introduction
This is an literate programming =init.el=.  Read Harry's [[https://harryrschwartz.com/2016/02/15/switching-to-a-literate-emacs-configuration][brief tutorial]] on how
this works and how to do it yourself.

* Helper for loading optional elisp files
#+BEGIN_SRC emacs-lisp
    (defun winny/load-file-when-present (file)
      "Load FILE when it's present.

  This suppresses an error caused by missing file.  It only prints
  out an error when the file throws an error."
      (condition-case err
          (load file nil t t)
        (file-missing nil)                  ; Ignore missing optional file
        (error (message "Failed to load %s: %s" file (error-message-string err))
               nil)))
#+END_SRC

* Utility stuff

** Full ISO 8601
From https://wilkesley.org/~ian/xah/emacs/elisp_datetime.html

#+begin_src emacs-lisp
  (defun winny/iso-8601 ()
    (concat
     (format-time-string "%Y-%m-%dT%T")
     ((lambda (x) (concat (substring x 0 3) ":" (substring x 3 5)))
      (format-time-string "%z"))))

  (defun winny/insert-iso-8601 ()
    (interactive)
    (insert (winny/iso-8601)))
#+end_src

* Load =host-pre-init.el=
#+BEGIN_SRC emacs-lisp
  (winny/load-file-when-present "~/.emacs.d/host-pre-init.el")
#+END_SRC

* Basic settings
Hardcode some settings that I wish to never change in any Emacs setup.

#+begin_src emacs-lisp
  (setq mode-require-final-newline t
        auto-revert-verbose nil
        async-shell-command-buffer 'new-buffer
        Man-notify-method 'friendly
        help-window-select 'other
        show-paren-delay 0.0
        custom-file "/dev/null"           ; XXX Windows
        custom-safe-themes t
        warning-suppress-types '((comp)))
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (menu-bar-mode -1)
  (column-number-mode 1)
  (blink-cursor-mode 1)
  (show-paren-mode 1)

#+end_src

* Set up load path
This way packages can be installed from submodules or tracked directly in my
git repository.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/")
#+END_SRC

* Package Setup
Set up packaging sources.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/") t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))
  (package-initialize)
  (defconst winny/initialized-cookie-path
    (concat user-emacs-directory "/.w-firstboot-initialized"))
  (unless (file-exists-p winny/initialized-cookie-path)
    (message "Detected first boot.  Doing initialization steps...")
    (package-refresh-contents)
    (with-temp-buffer
      (write-file winny/initialized-cookie-path))
    (message "First boot-only initialization complete."))
#+END_SRC

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
#+end_src

** TODO =use-package-always-ensure=
Set =use-package-always-ensure= to =t=... if one can figure out how to load
stuff from =site-lisp= and =site-packages= with this setting.

* Detect WSL

Load the locally maintained is-wsl package which is used later in this file.

#+BEGIN_SRC emacs-lisp
(use-package is-wsl)
#+END_SRC
* Better frame title
Give the desktop window title a nicer look.

#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("Emacs "
                                   (:eval (if buffer-file-name
                                            (replace-regexp-in-string (regexp-quote (or (getenv "HOME") "")) "~" buffer-file-name)
                                            (buffer-name)))
                                   " [%m] { "
                                   (:eval (string-join (mapcar #'(lambda (w) (buffer-name (window-buffer w))) (window-list)) ", "))
                                   " }"))
#+END_SRC

* Backup files
This section is inspired by
https://github.com/yanghaoxie/emacs.d#setting-related-in-build-in-features

Store backup files in =~/.emacs.d/var/backup/=.

#+BEGIN_SRC emacs-lisp
  (defvar winny/backup-directory
    (concat (file-name-as-directory user-emacs-directory) "var/backup"))
  (unless (file-exists-p winny/backup-directory)
    (make-directory winny/backup-directory t))
  (setq backup-directory-alist
        `(("." . ,winny/backup-directory)))
#+END_SRC

Store auto-save files in =~/.emacs.d/var/auto-save/=
#+BEGIN_SRC emacs-lisp
  (defvar winny/emacs-autosave-directory (concat (file-name-as-directory user-emacs-directory) "var/auto-save/"))
  (unless (file-exists-p winny/emacs-autosave-directory)
    (make-directory winny/emacs-autosave-directory t))
  (setq auto-save-file-name-transforms
        `((".*" ,winny/emacs-autosave-directory t)))
#+END_SRC
* Initialization helpers
** Toggle showing matching parenthesis for the current buffer only

#+BEGIN_SRC emacs-lisp
(defun show-paren-local-mode (&optional arg)
  "Toggle visibility of matching parenthesis for the current buffer.
When ARG is positive or not a number, enable function
`show-paren-mode', else disable it."
  (interactive)
  (setq-local show-paren-mode
              (cond
               ((numberp arg) (> arg 0))
               ((not arg) (not show-paren-mode))
               (t t)))
  (when (called-interactively-p 'interactive)
    (message "show-paren-mode %s in current buffer." (if show-paren-mode "enabled" "disabled"))))
#+END_SRC
** Easy way to add file extensions to a major mode
#+BEGIN_SRC emacs-lisp
(defun add-to-auto-mode-alist (mm extension &rest extensions)
  "Add major mode MM for EXTENSION and EXTENSIONS to the `auto-mode-alist'.
EXTENSION may also be a list."
  (let ((ls (if (listp extension)
              (append extension extensions)
              (cons extension extensions))))
    (dolist (ext ls)
      (add-to-list 'auto-mode-alist (cons (concat "\\." ext "\\'") mm)))
    auto-mode-alist))
#+END_SRC
* Language support
This section also includes file-format support, as file-formats can be thought
of as languages :)

** Racket
The core racket-mode.

#+BEGIN_SRC emacs-lisp
  (use-package racket-mode
    :ensure t
    :config
    (setq racket-show-functions 'racket-show-echo-area)
    :init
    (add-hook
     'racket-mode-hook
     (defun winny/racket-mode-hook ()
       (put 'bit-string-case 'racket-indent-function 'defun)
       ;; Defer to Emacs default value.  Note to self, if I modify this variable
       ;; I need to use (set-default-value ...)
       (setq-local comment-column (default-value 'comment-column))))
    (add-hook 'racket-mode-hook
              'racket-xp-mode))
#+END_SRC

And a locally installed =scribble.el= for scribble markup.

#+BEGIN_SRC emacs-lisp
(use-package scribble)
#+END_SRC

** Fennel
#+begin_src emacs-lisp
  (use-package fennel-mode
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.fnl\\'" . fennel-mode)))
#+end_src

** Common Lisp
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t
    :init
    (setq inferior-lisp-program "sbcl"))
#+END_SRC

** LaTeX/auctex
I install this via my distro's package manager, so no =use-package= here.

#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook (lambda ()
                           (setq word-wrap t)))
#+END_SRC
** Lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :ensure t
  :custom
  ((lua-indent-level 2)))
#+END_SRC

** Python

I've given up on jedi.  I am not a fan.  It doesn't work like you expect it to,
and is very moody.  TODO: look into setting up Python LSP.

#+BEGIN_SRC emacs-lisp
  (use-package python-mode
    :ensure t)
#+END_SRC

** Ruby
The default ruby mode is not very nice.  So use =enh-ruby-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package enh-ruby-mode
    :ensure t
    :init
    ;; Not sure if any if this is needed.  So commenting it out.
    ;; (autoload 'enh-ruby-mode "enh-ruby-mode" "Major mode for ruby files" t)
    ;; (add-to-auto-mode-alist 'enh-ruby-mode "rb")
    ;; (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))
    )
#+END_SRC

** C# (.Net support)

*** C# support
Syntax highlighting major mode.

#+BEGIN_SRC emacs-lisp
(use-package csharp-mode
  :ensure t)
#+END_SRC

*** csproj support
Major mode for csproj and other msbuild project files.

#+BEGIN_SRC emacs-lisp
(use-package csproj-mode
  :ensure t)
#+END_SRC

*** dotnet cli helper
This makes it possible to run some dotnet commands via emacs.

#+BEGIN_SRC emacs-lisp
(use-package dotnet
  :ensure t
  :after csharp-mode
  :init
  (add-hook 'csharp-mode-hook 'dotnet-mode))
#+END_SRC

*** omnisharp (code completion, linting, intellisense)
This is the secret sauce for dotnet core support in emacs.  It gives code
completion, suggestions, errors, and so on.  It is the same stuff that VSCode
uses internally.

#+BEGIN_SRC emacs-lisp
(use-package omnisharp
  :ensure t
  :after csharp-mode
  :after company
  :init
  (add-hook 'csharp-mode-hook 'omnisharp-mode)
  (add-to-list 'company-backends 'company-omnisharp))
#+END_SRC

*** dotnet core
Mark the dotnet core =.DotSettings= files as xml.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.DotSettings\\'" . xml-mode))
#+END_SRC
** Powershell
#+BEGIN_SRC emacs-lisp
(use-package powershell
  :ensure t
  :hook (powershell-mode
         .
         (lambda ()
           ;; No don't override a standard emacs key, really what were they thinking?
           (local-unset-key (kbd "M-`"))
           ;; TODO: bind `powershell-escape-selection' to something else...
           )))
#+END_SRC
** Web stuff

*** Coffee script
#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
    :ensure t
    :init
    (setq coffee-tab-width 2))
#+END_SRC

*** HTML/template support
web-mode is pretty great.  It supports all the cool template types.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    ;; web-mode
    (add-to-auto-mode-alist 'web-mode "php" "phtml" "tpl" "[agj]sp" "as[cp]x"
                            "erb" "mustache" "d?html")
    (defadvice web-mode-highlight-part (around tweak-jsx activate)
      (if (equal web-mode-content-type "jsx")
        (let ((web-mode-enable-part-face nil))
          ad-do-it)
        ad-do-it))
    (setq web-mode-auto-close-style 2
          web-mode-enable-auto-closing t
          web-mode-code-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-markup-indent-offset 2
          )
  ;; (add-hook 'web-mode-hook (lambda ()
  ;;                            (setq web-mode-markup-indent-offset 2)
  ;;                            (setq web-mode-css-indent-offset 2)
  ;;                            (setq web-mode-code-indent-offset 2)))
    )
#+END_SRC
*** TSX/JSX
#+begin_src emacs-lisp
  (straight-use-package '(tsi :type git :host github :repo "orzechowskid/tsi.el"))

  (straight-use-package '(tsx-mode :type git :host github :repo "orzechowskid/tsx-mode.el" :branch "emacs28"))
#+end_src
*** Svelte
A pretty cool framework for modern component web applications.

#+BEGIN_SRC emacs-lisp
(use-package svelte-mode
  :ensure t)
#+END_SRC

*** Jade HTML templates
Maybe I should remove this.  Haven't used a Jade template for a long time.

#+BEGIN_SRC emacs-lisp
(use-package jade-mode
  :ensure t)
#+END_SRC
*** Javascript
#+BEGIN_SRC emacs-lisp
(setq js-indent-level 2)
#+END_SRC
*** Typescrypt
#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t)

  (use-package tide
    :ensure t
    :after typescript-mode
    :after flycheck
    :after company
    :after editorconfig
    :init
    (defun setup-tide-mode ()
      (interactive)
      (tide-setup)
      (flycheck-mode +1)
      (setq flycheck-check-syntax-automatically '(save mode-enabled))
      (eldoc-mode +1)
      (tide-hl-identifier-mode +1)
      ;; company is an optional dependency. You have to
      ;; install it separately via package-install
      ;; `M-x package-install [ret] company`
      (company-mode +1))
    ;; formats the buffer before saving
    (add-hook 'before-save-hook 'tide-format-before-save)

    (add-hook 'typescript-mode-hook #'setup-tide-mode)
    (add-hook 'editorconfig-after-apply-functions (defun winny/fix-tide-indentation (props)
                                                    (when (and (boundp 'tide-mode) tide-mode)
                                                      (tide-command:configure)))))


#+end_src
*** Prisma (DSL for schemas)
#+begin_src emacs-lisp
  (use-package prisma-mode
    :after (lsp)
    :load-path "~/.emacs.d/site-packages/emacs-prisma-mode")
#+end_src

** Scala

=scalpp= was a file extension I used for cpp prerocessed code.  =cool= was a
file extension for a compilers course I took.  It was a subset of Scala, so I
used this major mode.  =coop= is cpp preprocessed code.

#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :ensure t
  :mode "\\.coo[lp]\\'"
  :mode "\\.scalpp\\'")
#+END_SRC

** Golang

It turns out golang mode is not strict about indentation despite the toolchain
being pretty strict about that sort of thing.  So that's what the hook does.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t
    :after (lsp-mode)
    :init
    (add-hook 'go-mode-hook #'lsp-deferred)
    (add-hook 'go-mode-hook
              (defun lsp-go-install-save-hooks ()
                (add-hook 'before-save-hook #'lsp-format-buffer t t)
                (add-hook 'before-save-hook #'lsp-organize-imports t t)))
    (add-hook 'go-mode-hook
              (defun winny/go-hook ()
                "My Go hook"
                (setq-local tab-width 4))))
#+END_SRC

** Haskell

#+begin_src emacs-lisp
  (use-package haskell-mode
    :ensure t
    :init
    (setq haskell-interactive-popup-errors nil))
#+end_src

** Ocaml

#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t)
#+end_src

** Zig
#+begin_src emacs-lisp
  (use-package zig-mode
    :ensure t)
#+end_src
** LSP
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :bind-keymap (("C-'" . lsp-command-map)))
#+end_src
** Packaging language modes

*** nix
The nix package language and configuration language.

#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :ensure t)
#+END_SRC

*** PKGBUILD
The bash-based packaging format used for archlinux.

#+BEGIN_SRC emacs-lisp
(use-package pkgbuild-mode
  :ensure t)
#+END_SRC

*** ebuild
(This is installed via the package manager.)

#+BEGIN_SRC sh
eix app-emacs/ebuild-mode
#+END_SRC
** Graphviz .dot files
See https://www.graphviz.org/doc/info/lang.html

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t)
#+END_SRC
** Java ecosystem

*** Kotlin
A Java replacement by Google.

#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode
  :ensure t)
#+END_SRC

*** Gradle (build tool)
See also [[Groovy][groovy-mode]] for syntax highlighting.

#+begin_src emacs-lisp
  (use-package gradle-mode
    :ensure t)
#+end_src

*** Groovy
(And Gradle syntax highlighting)

#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t)
#+end_src
*** Java LSP
#+begin_src emacs-lisp
  (use-package lsp-java
    :after (lsp)
    :ensure t
    :init (add-hook 'java-mode-hook 'lsp))
#+end_src
** Ledger
For [[https://plaintextaccounting.org/][plain text accounting]].

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :ensure t
  :after company-mode
  :hook
  ((ledger-mode-hook
    .
    (lambda ()
      (company-mode 1)))))
#+END_SRC
** CSV
Always useful to have better CSV tooling.

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :ensure t
  :mode "\\.[Cc][Ss][Vv]\\'")
#+END_SRC
** Rust
Nice and simple.  Just install rust-mode.

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :ensure t)
#+END_SRC
** Swift

#+begin_src emacs-lisp
  (use-package swift-mode
    :ensure t)
#+end_src

** JSON
While one could use =javascript-mode=, =json-mode= restricts the syntax to just the
JSON stuff.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t)
#+END_SRC
** YAML
Yet another silly markup language.

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t)
#+END_SRC
** XML extensions
Format XML documents.  Not perfect as it depends an =xmllint= and that tends to
clean up dirty XML documents (e.g. add DTDs).
#+begin_src emacs-lisp
  (fset 'winny/xml-format
       (kmacro-lambda-form [?\C-x ?h ?\C-u ?\M-| ?x ?m ?l ?l ?i ?n ?t ?  ?- ?- ?f ?o ?r ?m ?a ?t ?  ?- return] 0 "%d"))
#+end_src

Add some other known extensions to ~xml-mode~.
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.xsd\\'" . xml-mode)) ; XML Schema Definition
  (add-to-list 'auto-mode-alist '("\\.wsdl\\'" . xml-mode)) ; Web Services Description Language
  (add-to-list 'auto-mode-alist '("\\.jca\\'" . xml-mode)) ; Java Connector Architecture Adapter files
#+end_src
** TOML
Tom's obvious minimal language.

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :ensure t)
#+END_SRC
** Sed
For =sed(1)= scripts.

#+BEGIN_SRC emacs-lisp
(use-package sed-mode
  :ensure t)
#+END_SRC
** ssh configuration files
This adds syntax highlighting for =ssh_config=, =sshd_config=, =known_hosts=,
and =authorized_keys=.

#+BEGIN_SRC emacs-lisp
(use-package ssh-config-mode
  :ensure t)
#+END_SRC
** .gitignore
Also adds major modes for git attributes and git config files.
=gitignore-mode= Helps with making sure globs make sense.

#+BEGIN_SRC emacs-lisp
(use-package git-modes
  :ensure t)
#+END_SRC
** Markdown
The markdown markup language.

#+BEGIN_SRC emacs-lisp
  (use-package edit-indirect
    :ensure t
    :init
    (require 'edit-indirect)
    (define-key edit-indirect-mode-map (kbd "C-c C-'") 'edit-indirect-commit))

  (use-package markdown-mode
    :after (edit-indirect)
    :ensure t
    :init
    (require 'markdown-mode)
    (setq markdown-asymmetric-header t)
    (define-key markdown-mode-map (kbd "C-c C-'") 'markdown-edit-code-block))
#+END_SRC
** Unison profiles
The unison synchronization tool has a somewhat weird syntax, so I wrote a major
mode to highlight it more accurately.

#+BEGIN_SRC emacs-lisp
(use-package unison)
#+END_SRC
** C mode
*** All C-like
I can't remember what this does.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda ()
            (c-set-offset 'substatement-open 0)
            (if (assoc 'inexpr-class c-offsets-alist)
              (c-set-offset 'inexpr-class 0))))
#+END_SRC
*** C language specifically
Set default style and use tabs in C files by default.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-hook (lambda ()
                         (setq indent-tabs-mode t)
                         (c-set-style "bsd")))
#+END_SRC
** Meson
#+begin_src emacs-lisp
  (use-package meson-mode
    :ensure t)
#+end_src
** Qlik
#+begin_src emacs-lisp
  (add-to-auto-mode-alist 'sql-mode "qvs")
#+end_src
** Perl
*** perldoc support
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t)

  (use-package helm-perldoc
    :ensure t
    :after (helm)
    :init
    (helm-perldoc:setup))
#+END_SRC
** Erlang
#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :ensure t
    :init
    (require 'erlang-start))
#+END_SRC
** Dockerfile
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+end_src
** SQL
#+begin_src emacs-lisp
  (use-package sql-indent
    :ensure t
    :hook ((sql-mode . sqlind-minor-mode)))
#+end_src
** CMake
#+begin_src emacs-lisp
  (use-package cmake-mode
    :ensure t)
#+end_src
** Bison (Lex/Yacc)
#+begin_src emacs-lisp
  (use-package bison-mode
    :ensure t)
#+end_src
** BASIC
#+begin_src emacs-lisp
  (use-package basic-mode
    :ensure t
    :init
    (setq basic-auto-number 20
          basic-line-number-cols 4))
#+end_src
** Clojure
#+begin_src emacs-lisp
    (use-package clojure-mode
      :ensure t)
#+end_src
** Linux Firewall (nft)
#+begin_src elisp
  (use-package nftables-mode
    :ensure t)
#+end_src

* Hex editing
#+begin_src emacs-lisp
  (use-package nhexl-mode
    :ensure t
    :init
    ;; defalias needs symbols: it's a function, not a macro.
    (defalias 'hex-edit 'nhexl-mode)
    (add-hook 'nhexl-mode-hook #'(lambda ()
                                   (setq-local so-long-action 'longlines-mode))))
#+end_src
* Whitespace
** Show trailing whitespace on some major modes by default.

#+BEGIN_SRC emacs-lisp
  (mapc (lambda (m) (add-hook (intern (concat (symbol-name m) "-mode-hook"))
                              (defun whitespace-hook ()
                                "Hook to make trailing whitespace visible."
                                (setq-local show-trailing-whitespace t))))
        '(c csv c++ python ruby enh-ruby js lisp web racket org TeX haskell makefile))
#+END_SRC
** Add command and bind key to toggle trailing whitespace
#+BEGIN_SRC emacs-lisp
(defun show-trailing-whitespace (n)
  "Toggle the highlight of trailing whitespace for the current buffer.

  When N is nil, toggle the highlight setting.
  When N is non-negative, enable the highlight setting.
  When N is negative, disable the highlight setting."
  (interactive "P")
  (setq-local show-trailing-whitespace
              (cond
               ((eq n nil) (not show-trailing-whitespace))
               ((< n 0) nil)
               (t t)))
  (force-window-update)
  (message (if show-trailing-whitespace
             "Showing trailing whitespace."
             "Hiding trailing whitespace.")))

(global-set-key (kbd "C-x M-w") 'show-trailing-whitespace)
#+END_SRC
* File manager stuff
** dired
*** Automatically update directory listings

Except on Windows where Disk IO seems to be prohibitively slow.  Could just be
work Anti Virus ¯\_(ツ)_/¯.  On Windows, typing =g= in a dired buffer causes an
excessively long delay (tens of seconds) in a directory with 4000 entries.

#+BEGIN_SRC emacs-lisp
  (unless (or (member system-type '(ms-dos windows-nt cygwin)) is-wsl)
    (add-hook 'dired-mode-hook 'auto-revert-mode))
#+END_SRC

*** Add =C-c n= to create an empty file
#+BEGIN_SRC emacs-lisp
(eval-after-load 'dired
  '(progn
     (define-key dired-mode-map (kbd "C-c n") 'dired-create-file)
     (defun dired-create-file (file)
       "Create a file called FILE.
If FILE already exists, signal an error."
       (interactive
        (list (read-file-name "Create file: " (dired-current-directory))))
       (let* ((expanded (expand-file-name file))
              (try expanded)
              (dir (directory-file-name (file-name-directory expanded)))
              new)
         (if (file-exists-p expanded)
           (error "Cannot create file %s: file exists" expanded))
         ;; Find the topmost nonexistent parent dir (variable `new')
         (while (and try (not (file-exists-p try)) (not (equal new try)))
           (setq new try
                 try (directory-file-name (file-name-directory try))))
         (when (not (file-exists-p dir))
           (make-directory dir t))
         (write-region "" nil expanded t)
         (when new
           (dired-add-file new)
           (dired-move-to-filename))))))
#+END_SRC
** dired+
A better dired.

#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :disabled)
#+END_SRC
** sunrise commander
A OFM (like midnight commander) for emacs.

#+BEGIN_SRC emacs-lisp
  ;; (use-package sunrise
  ;;   :disabled
  ;;   :load-path "~/.emacs.d/site-packages/sunrise-commander")
#+END_SRC
** neotree side pane
This is a handy side pane with a navigable tree of folders and files.  This
also configures neotree to sort by file extension.

#+BEGIN_SRC emacs-lisp
(defun string</extension (x y)
  "Using the file extension, indicate if X is less than Y."
  (let ((x-ext (f-ext x))
        (y-ext (f-ext y)))
    (cond
     ((string= x-ext y-ext) (string< x y))
     ((not x-ext) t)
     ((not y-ext) nil)
     (t (string< x-ext y-ext)))))
(use-package neotree
  :ensure t
  :bind (([f8] . neotree-toggle))
  :bind (:map neotree-mode-map
              ("^" . neotree-select-up-node)
              ("v" . neotree-select-down-node))
  :config (setq neo-filepath-sort-function 'string</extension))
#+END_SRC
* Feature reloading
This should be moved to its own emacs lisp file.  =winny/reload-major-mode=
attempts to reload a major mode.  This helps when making certain kinds
of changes to el files.  No need to restart emacs.  Or partially re-evaluate,
only to realize it didn't work as you expected.

#+BEGIN_SRC emacs-lisp
(defun winny/reload-feature (feature &optional force) ; Why the HECK is this
                                                      ; not standard?
  "Reload FEATURE optionally FORCE the `unload-feature' call."
  (interactive
   (list
    (read-feature "Unload feature: " t)
    current-prefix-arg))
  (let ((f (feature-file feature)))
    (unload-feature feature force)
    (load f)))

(require 'loadhist)                     ; For `file-provides'
(defun winny/reload-major-mode ()
  "Reload the current major mode.

TODO: This should be generalized to any feature, and will
re-enable any minor or major modes present in the feature's
file."
  (interactive)
  (letrec ((mode major-mode)
           (f (cdr (find-function-library mode)))
           (buffers (loop for b in (buffer-list)
                          when (eq (buffer-local-value 'major-mode b) mode)
                          collect b)))
    (loop for feature in (file-provides f)
          do (unload-feature feature t))
    (load f)
    (loop for b in buffers
          do (with-current-buffer b
               (funcall mode)))))
#+END_SRC
* =custom-mode= helpers
Add the following keys to help with navigating =custom-mode=:

| Key     | Command                       | Description                                                                                 |
|---------+-------------------------------+---------------------------------------------------------------------------------------------|
| =^=     | =Custom-goto-parent=          | Go to parent node.                                                                          |
| =M-n=   | =winny/forward-child-widget=  | Go to next configurable option.                                                             |
| =M-p=   | =winny/backward-child-widget= | Go to previous configurable option.                                                         |
| =M-RET= | =Custom-newline=              | Lazy bind so one doesn't have to release meta key when wishing to expand/contract a widget. |

The =^= aligns with dired's usage of =^= to go up one directory.

#+BEGIN_SRC emacs-lisp
(require 'cus-edit)
(defconst winny/child-widget-regex "^\\(Hide\\|Show Value\\|Show\\)")
(defun winny/forward-child-widget (&optional arg)
  "Navigate to next child widget by ARG.
Use a Negative ARG to navigate backwards."
  (interactive "p")
  (when (and (looking-at winny/child-widget-regex) (> arg 0))
    (setq arg (+ 1 arg)))
  (condition-case nil
      (progn
        (re-search-forward winny/child-widget-regex nil nil arg)
        ;; Ensure point is at the beginning of the line.
        (move-beginning-of-line nil))
    (error (ding))))
(defun winny/backward-child-widget (&optional arg)
  "Navigate to previous child widget by ARG.
Use a Negative ARG to navigate forwards."
  (interactive "p")
  (winny/forward-child-widget (- arg)))

(define-key custom-mode-map "^" 'Custom-goto-parent)
(define-key custom-mode-map (kbd "M-n") 'winny/forward-child-widget)
(define-key custom-mode-map (kbd "M-p") 'winny/backward-child-widget)
(define-key custom-mode-map (kbd "M-RET") 'Custom-newline)
#+END_SRC
* Theme-ing
** The themes
*** cyberpunk
My goto theme.

#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
  :ensure t)
#+END_SRC

*** tao

#+begin_src emacs-lisp
  (use-package tao-theme
    :ensure t)
#+end_src
*** Others for the moods
#+begin_src emacs-lisp
  (use-package uwu-theme
    :ensure t)

  (use-package abyss-theme
    :ensure t)
#+end_src
*** Modeline

#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t)
  (use-package doom-modeline
    :ensure t
    :after (nerd-icons)
    :init (doom-modeline-mode 1))
#+end_src

** A facility to streamline theme selection
#+BEGIN_SRC emacs-lisp
  (load "switch-theme.el" t t)
  (setq winny/default-theme 'cyberpunk)
  (use-package smart-mode-line
    :ensure t
    :disabled
    :init
    (require smart-mode-line)
    (setq sml/col-number-format "%3c"
          sml/line-number-format "%4l"
          sml/mode-width 'right
          sml/numbers-separator ","
          sml/replacer-regexp-list '(("^~/\\.emacs\\.d/elpa/" ":ELPA:")
                                     ("^~/\\.emacs\\.d/" ":ED:"))
          sml/theme 'respectful)
    (add-hook 'winny/after-theme-switch-hook 'sml/setup t t))
#+END_SRC
** Helper to describe theme
#+BEGIN_SRC emacs-lisp
(defun describe-current-theme ()
  "Describe the current theme, ignoring smart-mode-line themes."
  (interactive)
  (describe-theme
   (car
    (cl-remove-if (lambda (x)
                    (string-prefix-p "smart-mode-line" (symbol-name x)))
                  custom-enabled-themes))))
#+END_SRC
* Emacs Performance and debugging

** Profiler
Bind the emacs profiler to some keys under the =C-x M-p= map.

#+BEGIN_SRC emacs-lisp
(require 'profiler)
(global-set-key (kbd "C-x M-p s") 'profiler-start)
(global-set-key (kbd "C-x M-p q") 'profiler-stop)
(global-set-key (kbd "C-x M-p r") 'profiler-report)
#+END_SRC

** ESUP - Emacs Start Up Profiler

#+BEGIN_SRC emacs-lisp
(use-package esup
  :ensure t
  ;; To use MELPA Stable use ":pin mepla-stable",
  :pin melpa
  :commands (esup))
#+END_SRC

** Debug on error or quit
Function =toggle-debug-on-error= is always available, but if there is an error
that prevents =M-x toggle-debug-on-error RET= from completing, you won't be
able to enable this functionality, thereby be unable to get an error trace
(sad).  The work around is to make a helper function, then bind it to a key on
the global keymap.  In this case =C-x \= will toggle debug on error.  =C-u C-x
\= will toggle debug on quit.

#+BEGIN_SRC emacs-lisp
(defun winny/toggle-debug-on-error-or-quit (&optional on-quit)
  "Toggle debug on error, or quit with non-nil prefix argument.
When ON-QUIT is non-nil toggle debug on quit instead."
  (interactive "P")
  (if on-quit
    (toggle-debug-on-quit)
    (toggle-debug-on-error)))

(global-set-key (kbd "C-x \\") 'winny/toggle-debug-on-error-or-quit)
#+END_SRC
* org-mode
Ye ole fabulous productivity tool.

** Note to self about blocks
In recent org-mode =<sTAB= no longer works.  One can restore this functionality
using =(require 'org-tempo)= --- this reimplements the old behavior.  On the
other hand the new behavior using =C-c C-, s= is much cleaner, allowing the
user to dispatch to any known block type from a menu.  It is one extra
keystroke, but I think I'll live.

** Package setup

See:

- [[info:org#Headlines][org#Headlines]]
- [[info:org#Catching invisible edits][org#Catching invisible edits]]


#+begin_src emacs-lisp
  (use-package org
    :pin gnu
    :ensure t
    :init
    (setq org-special-ctrl-a t
          org-special-ctrl-k t
          org-special-ctrl-k 'error
          org-catch-invisible-edits t
          org-startup-folded 'fold
          ;; https://emacs.stackexchange.com/questions/64222/insert-link-to-a-heading-with-id
          org-id-link-to-org-use-id 'create-if-interactive
          user-full-name "Winston Weinert (winny)"
          user-mail-address "hello@winny.tech"
          org-capture-templates
          '(("a" "Anything" entry
             (file+datetree "~/files/notes/unsorted.org")
             (file "~/.emacs.d/org-capture-templates/unsorted.org"))
            ("j" "Journal Entry" entry
             (file+datetree "~/files/writings/journal/journal.org")
             (file "~/.emacs.d/org-capture-templates/journal-item.org"))
            ("t" "Todo list item" entry
             (file+headline "~/files/notes/todo.org" "Inbox")
             (file "~/.emacs.d/org-capture-templates/todo-item.org")))
          org-default-notes-file "~/files/notes/unsorted.org"))
  (use-package org-contrib
    :ensure t
    :after org)
#+end_src

** org-cliplink

=C-c C-y= is bound to something that I've never used related to timekeeping.

#+begin_src emacs-lisp
  (use-package org-cliplink
    :ensure t
    :after org
    :init
    (define-key org-mode-map (kbd "C-c C-y") 'org-cliplink))
#+end_src

** Main hook
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (defun winny/org-hook ()
                             (setq word-wrap t)
                             (turn-on-auto-fill)
                             (org-indent-mode 1)))
#+END_SRC

** Global org-mode keys
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-switchb)
#+END_SRC

** Org-mode specific keys
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "M-n") 'org-next-visible-heading)
  (define-key org-mode-map (kbd "M-p") 'org-previous-visible-heading)

  (define-key org-mode-map (kbd "<C-M-return>")
    (defun winny/org-goto-content ()
      "Go to content for heading or create a newline for content."
      (interactive)
      (org-end-of-meta-data)
      (org-show-hidden-entry)
      (when (org-at-heading-p)
        (open-line 1))))

  ;; Make it easier to enter/leave org block editing without lifting the Control
  ;; key.
  (define-key org-mode-map (kbd "C-c C-'") 'org-edit-special)
  (define-key org-src-mode-map (kbd "C-c C-'") 'org-edit-src-exit)

  (define-key org-mode-map (kbd "C-M-u") 'org-up-element)
#+END_SRC

** Insert created timestamp
#+BEGIN_SRC emacs-lisp
  (defvar winny/org-auto-insert-expiry-pattern-list '()
    "A list of regexes like the first element in `auto-mode-alist'
  cons cells.")
  (defun winny/org-insert-created ()
    "Insert created expiry information.
  Only insert when the variable the target filing file name matches
  a regex in `winny/org-auto-insert-expiry-pattern-list'."
    (when (let* ((base-buffer-file-name
                  (buffer-file-name (buffer-base-buffer (current-buffer))))
                 (case-fold-search
                  (file-name-case-insensitive-p base-buffer-file-name)))
            (assoc-default base-buffer-file-name
                           (mapcar #'(lambda (el) (cons el t))
                                   winny/org-auto-insert-expiry-pattern-list)
                           'string-match))
      (save-excursion
        (org-back-to-heading)
        (org-expiry-insert-created))))
  (add-hook 'org-capture-before-finalize-hook 'winny/org-insert-created)
  (add-hook 'org-insert-heading-hook 'winny/org-insert-created)
#+END_SRC
** Some helper functions/macros for org stuff
*** convert a table to a definition list
#+BEGIN_SRC emacs-lisp
(defun winny/org-table-line-to-definition-list (&optional arg)
  "Keyboard macro."
  (interactive "p")
  (kmacro-exec-ring-item (quote ([4 45 19 124 return 2 2 134217760 4 58 58 5 2 134217760 4 backspace return 11] 0 "%d")) arg))
#+END_SRC
*** Silly helper to increment footnotes
#+BEGIN_SRC emacs-lisp
(defun winny/increment-footnotes (count)
  "Increment all footnote numbers in buffer by `COUNT'."
  (interactive "p")
  (unless count
    (setq count 1))
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\[fn:\\([0-9]+\\)\\]" nil t)
      (message "m")
      (replace-match (number-to-string (+ count (string-to-number (match-string 1))))
                     nil nil nil 1))))
#+END_SRC
*** idk what this does but it was in my init.el
#+BEGIN_SRC emacs-lisp
(defun afs/org-replace-link-by-link-description ()
  "Replace an org link by its description or if empty its address."
  (interactive)
  (if (org-in-regexp org-bracket-link-regexp 1)
    (save-excursion
      (let ((remove (list (match-beginning 0) (match-end 0)))
            (description (if (match-end 3)
                           (org-match-string-no-properties 3)
                           (org-match-string-no-properties 1))))
        (apply 'delete-region remove)
        (insert description)))))
#+END_SRC
** Export stuff
*** ox-latex
#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-classes
             '("beamer"
               "\\documentclass\[presentation\]\{beamer\}"
               ("\\section\{%s\}" . "\\section*\{%s\}")
               ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
               ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))
#+END_SRC
*** ox-twbs
Pretty bootstrap based HTML export.

#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure t
    :after ox)
#+END_SRC
*** ox-hugo
Export to hugo markdown.  Great for blogging.

#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo
    :ensure t
    :after ox)
#+END_SRC
**** Helper commands to get productive

#+begin_src emacs-lisp
  (defun winny/new-blog-post ()
    (interactive)
    (find-file "~/pro/winny.tech/blog.winny.tech/content-org/all-posts.org")
    (goto-char (point-max))
    (org-previous-visible-heading 1)
    (org-meta-return))
#+end_src
** Modern org

Cleaner org-mode.

#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :init
    (with-eval-after-load 'org (global-org-modern-mode)))
#+end_src

** Babel (code evaluation)

*** Async execution
#+begin_src elisp
  (use-package ob-async
    :ensure t
    :after org
    :init
    (require 'ob-async))
#+end_src

*** Bash support

#+begin_src elisp
  (org-babel-do-load-languages 'org-babel-load-languages '((shell . t)))
#+end_src

* Code folding
Use =M-g f= to fold the region.  Use =M-g d= to delete the fold under point.
Use =M-g t= to toggle the fold at point.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :ensure t
  :after expand-region
  :init
  (defun winny/vimish-fold-defun ()
    "Fold the defun around point."
    (interactive)
    (lexical-let ((r (save-excursion (er/mark-defun) (list (region-beginning) (region-end)))))
      (vimish-fold (car r) (cadr r))))
  (defun winny/vimish-fold-delete (entire-buffer)
    "Fold region or entire buffer when ENTIRE-BUFFER is not nil."
    (interactive "P")
    (if entire-buffer
      (vimish-fold-delete-all)
      (vimish-fold-delete)))
  (global-set-key (kbd "M-g f") #'vimish-fold)
  (global-set-key (kbd "M-g M-f") #'vimish-fold)
  (global-set-key (kbd "M-g u") #'vimish-fold-unfold)
  (global-set-key (kbd "M-g M-u") #'vimish-fold-unfold)
  (global-set-key (kbd "M-g t") #'vimish-fold-toggle)
  (global-set-key (kbd "M-g M-t") #'vimish-fold-toggle)
  (global-set-key (kbd "M-g d") #'vimish-fold-delete)
  (global-set-key (kbd "M-g M-d") #'vimish-fold-delete))
#+END_SRC

* VCS/Git support

When following a symlink into a git repo, display a warning, but don't prompt
if it is okay.

#+begin_src emacs-lisp
  (setq vc-follow-symlinks nil)
#+end_src

** Magit
The best way to use git.  As long as you know =C-x g= to open the magit menu,
you are good to go.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status)
           ("C-x M-g" . magit-dispatch)
           ("C-x M-c" . magit-clone)
           :map magit-revision-mode-map
           ("C-c u" . magit-rev-parent))
    :init
    (fset 'magit-rev-parent
     (kmacro-lambda-form [?\M-< ?\C-s ?p ?a ?r ?e ?n ?t ?: return return] 0 "%d")))
#+END_SRC

** Git LFS

#+begin_src emacs-lisp
  (use-package magit-lfs
    :ensure t
    :after magit)
#+end_src

** Forge
Work with github and gitlab efficiently.

As of 2022-07-13 there's an issue with my forge setup, so disable temporarily
until a workaround can be determined.

#+BEGIN_SRC emacs-lisp
  (use-package forge
    :disabled
    :ensure t)
#+END_SRC

* Documentation/help browsers

** info
Sometimes I put texinfo files into =~/docs/info=.  Most distros do not package
mysql's texinfo, for example.  It sure beats firing up a web browser!

#+BEGIN_SRC emacs-lisp
(add-to-list 'Info-directory-list "~/docs/info" t)
#+END_SRC

Add a key to easily copy the current info node name.  This can be used to share
with others how to find docuemantion.

#+BEGIN_SRC emacs-lisp
(bind-key "y" #'Info-copy-current-node-name Info-mode-map)
#+END_SRC

** RFC reader (irfc)
In this repository.

#+BEGIN_SRC emacs-lisp
  (use-package irfc
    :hook (irfc-mode
           . (lambda ()
               (read-only-mode)         ; Make read only.
               (show-paren-local-mode -1))))
#+END_SRC

** Better =describe-*=
The =helpful= package takes over =C-h v=, =C-h k=, =C-h f= providing more
descriptive output and nicer formatting.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :ensure t
  :bind (("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)
         ("C-h f" . helpful-callable)))
#+END_SRC

** Show keys in the current mode-map
Say you start typing =C-x=.  After a brief delay this mode will show all
available keys at the bottom of the screen.  This can help with forgetting
keyboard shortcuts, as one tends to do with octopus-hand tools like Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode 1)
    :config
    ;; Address issue with tao-yin.  This is a hack.
    (set-face-attribute 'which-key-command-description-face nil :inherit nil))
#+END_SRC

** Show unbound keyboard shortcuts
No more guessing if a key is available.  This will show a list of all keys
available in a given mode map.  Use =C-h Y=.

#+BEGIN_SRC emacs-lisp
(use-package free-keys
  :ensure t
  :bind (("C-h Y" . free-keys)))
#+END_SRC
** Describe a face
#+BEGIN_SRC emacs-lisp
(defun what-face (pos)
  "Describe the face under point.

Prefix argument POS should be a location it the buffer."
  (interactive "d")
  (let ((face (or (get-char-property (pos) 'read-face-name)
                  (get-char-property (pos) 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Describe a theme
See [[Helper to describe theme][here]].

* Direnv
#+begin_src elisp
  (use-package direnv
    :ensure t
    :config
    (direnv-mode))
#+end_src
* Pull in ssh-agent via keychain
See https://www.funtoo.org/Keychain

#+BEGIN_SRC emacs-lisp
(use-package keychain-environment
  :ensure t
  :init
  (keychain-refresh-environment))
#+END_SRC
* Completion
** Vertico
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (setq read-file-name-completion-ignore-case t
          read-buffer-completion-ignore-case t
          completion-ignore-case t)
    (vertico-mode))

  (use-package savehist
    :init
    (savehist-mode))

  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    :ensure t
    ;; Either bind `marginalia-cycle' globally or only in the minibuffer
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))

  (use-package all-the-icons-completion
    :ensure t
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src

* Ensure XDG_RUNTIME_DIR is set
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook
          (defun winny/ensure-XDG_RUNTIME_DIR ()
            "Ensure XDG_RUNTIME_DIR is set.
Used by qutebrowser and other utilities."
            (let ((rd (getenv "XDG_RUNTIME_DIR")))
              (when (or (not rd) (string-empty-p rd))
                (setenv "XDG_RUNTIME_DIR" (format "/run/user/%d" (user-uid)))))))
#+END_SRC

* eww

** Create multiple eww buffers
This allows for =C-u M-x eww RET= to create a new buffer.  This is from
https://emacs.stackexchange.com/a/24477/9163 .

#+BEGIN_SRC emacs-lisp
(defun modi/force-new-eww-buffer (orig-fun &rest args)
  "When prefix argument is used, a new eww buffer will be created,
regardless of whether the current buffer is in `eww-mode'."
  (if current-prefix-arg
    (with-temp-buffer
      (apply orig-fun args))
    (apply orig-fun args)))
(advice-add 'eww :around #'modi/force-new-eww-buffer)
#+END_SRC

It appears the above does not work :(.  This is a convenient work around.  Just
use =M-x eww-new RET=

#+BEGIN_SRC emacs-lisp
(defun eww-new ()
  (interactive)
  (let ((url (read-from-minibuffer "Enter URL or keywords: ")))
    (switch-to-buffer (generate-new-buffer "*eww*"))
    (eww-mode)
    (eww url)))
#+END_SRC

** Better eww appearance
Using writeroom-mode, one can center the text in eww-mode, reduce the paragraph
width, and increase line height.

#+BEGIN_SRC emacs-lisp
(add-hook 'eww-mode-hook 'writeroom-mode)
#+END_SRC

* Code searching

** ripgrep

#+BEGIN_SRC emacs-lisp
  (use-package rg
    :ensure t
    :init
    ;; Move over the default rg search to `rg/files'.
    (rg-define-search rg/files :confirm prefix)
    ;; Don't prompt for file types.  Note: "all" will only search the files known
    ;; to ripgrep to be interesting.  This won't work if working with
    ;; non-standard file extensions.  Instead use "everything", which appears to
    ;; be what ripgrep does by default anyways.
    ;;
    ;; Created https://github.com/dajva/rg.el/issues/131 to memorialize this
    ;; surprising behavior.
    (rg-define-search rg :confirm prefix :files "everything"))
#+END_SRC

** Ergonomic search key
Use =f3= as an ergonomic search key.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "<f3>") 'isearch-forward)
(define-key global-map (kbd "<S-f3>") 'isearch-backward)
(define-key isearch-mode-map (kbd "<f3>") 'isearch-repeat-forward)
(define-key isearch-mode-map (kbd "<S-f3>") 'isearch-repeat-backward)
#+END_SRC

** Occur
Occcur is pretty cool, but not sure why =n= and =p= do not move the cursor down
and up?

#+BEGIN_SRC emacs-lisp
(define-key occur-mode-map (kbd "p") 'previous-line)
(define-key occur-mode-map (kbd "n") 'next-line)
#+END_SRC

** Swiper
A rather nice incremental search.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind (("C-x M-s" . swiper)))
#+END_SRC
* Flyspell/flycheck/etc

** Flyspell
Check spelling of prose in writing modes.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

And make it less distracting because jeeeeeeeeeeeeeeeez!

#+begin_src emacs-lisp
  (require 'flyspell)
  (setq flyspell-persistent-highlight nil)

  ;; https://emacs.stackexchange.com/questions/450/intelligent-spell-checking-in-org-mode
  (add-to-list 'ispell-skip-region-alist '(":\\(properties\\|LOGBOOK\\|PROPERTIES\\|LOGBOOK\\):" . ":END:"))
  (add-to-list 'ispell-skip-region-alist '("#\\+\\(BEGIN_SRC\\|begin_src\\)" . "#\\+\\(END_SRC\\|end_src\\)"))

#+end_src

** flycheck
Enable it globally.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    ;; Disable the Elisp checkdoc checker.  I'm not sure why this is enabled by
    ;; default as most elisp users write is ad-hoc and
    ;; undocumented... https://emacs.stackexchange.com/a/10854/9163
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (global-flycheck-mode 1))
#+END_SRC

* Code completion

** company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init
  (global-set-key (kbd "<C-tab>") 'company-complete)
  ;; Temporarily disable this hook until implications are understood.  Add the
  ;; line to host.el instead.
  ;; (add-hook 'after-init-hook 'global-company-mode)
  )
#+END_SRC

* Navigation

** Reverse cycle windows
=C-x o= goes to the next window.  But what about going to the previous window?
One can do =C-u -1 C-x o= but we can do better than that.

This adds =C-x O= to cycle backwards.

#+BEGIN_SRC emacs-lisp
(defun other-window-reverse (offset &optional all-frames)
  "`other-window' but in reverse."
  (interactive "p")
  (other-window (- (if (numberp offset) offset 1)) all-frames))

(global-set-key (kbd "C-x O") 'other-window-reverse)
#+END_SRC

** Ergonomic cycle key
#+begin_src emacs-lisp
  (global-set-key (kbd "<f4>") 'other-window)
  (global-set-key (kbd "S-<f4>") 'other-window)
#+end_src

** Slightly adjusting the viewport
This scrolls the viewport up and down.  It keeps the cursor at the same line
except if the line the cursor is presently on scrolls off the screen.  Then the
cursor moves to the line closest to the previous line that is still on the
screen.  It is bound to =M-N= and =M-P=.

#+BEGIN_SRC emacs-lisp
(defun scroll-up-1 ()
  "Scroll up by 1 line."
  (interactive)
  (scroll-up 1))
(defun scroll-down-1 ()
  "Scroll down by 1 line."
  (interactive)
  (scroll-down 1))

(global-set-key (kbd "M-N") 'scroll-up-1)
(global-set-key (kbd "M-P") 'scroll-down-1)
#+END_SRC

** Move buffers between windows
#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-x w p" . buf-move-up)
         ("C-x w n" . buf-move-down)
         ("C-x w b" . buf-move-left)
         ("C-x w f" . buf-move-right)))
#+END_SRC

** Recenter on page navigation
#+BEGIN_SRC emacs-lisp
(defun traverse-page--recenter-top (&optional count)
  "Recenter top, ignoring COUNT."
  (when (get-buffer-window)
    (recenter-top-bottom 0)))

(advice-add 'forward-page :after #'traverse-page--recenter-top)
(advice-add 'backward-page :after #'traverse-page--recenter-top)
#+END_SRC

** Easier to type keys for page navigation
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-M-next>") 'forward-page)
(global-set-key (kbd "<C-M-prior>") 'backward-page)
#+END_SRC

** Winner
Navigate history of window/buffer/frame layout.  Use =C-c <left>= to go to
previous layout, and =C-c <right>= to go to next layout.

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** Speed up scrolling
This works by disabling font locking (syntax highlighting) when rendering is
taking too long, then restores font locking when scrolling stops.

#+BEGIN_SRC emacs-lisp
(use-package fast-scroll
  :ensure t
  :config
  ;; Keep `mode-line-format' the same. This addresses a problem with
  ;; disappearing winum mode-line indicies.
  (defun fast-scroll-default-mode-line ()
    mode-line-format)
  :init
  (fast-scroll-mode 1))
#+END_SRC

** Speed up rendering of very long lines

New with Emacs 27.1.  See =M-x so-long-commentary RET=.

#+begin_src emacs-lisp
  (global-so-long-mode 1)
#+end_src

** Alternate keys to traverse between delimited phrases
One can use =C-M-B= and =C-M-f= to go backward and forward between
s-expressions, but sometimes that is a bit awkward.  So add keys =C-x ,= and
=C-x .= to do the same thing.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x," 'backward-sexp)
(global-set-key "\C-x." 'forward-sexp)
#+END_SRC

** Globally enable/disable line numbers in =prog-mode=

This feature allows for the quick toggle of line numbers.  I personally don't
find line numbers very handy, but they help pair programmers communicate which
particular code fragment they are talking about.

Type =C-x M-l= to toggle line numbers.

#+begin_src emacs-lisp
  (defun enable-line-numbers ()
    "Enable line numbers in prog-mode."
    (interactive)
    (cl-loop for buf in (buffer-list)
             collect (with-current-buffer buf
                       (when (derived-mode-p 'prog-mode)
                         (display-line-numbers-mode 1))))
    (add-hook 'prog-mode-hook 'winny--enable-line-numbers)
    (when (called-interactively-p 'interactive)
      (message "Line numbers ENABLED in prog-modes."))
    t)

  (defun disable-line-numbers ()
    "Disable line numbers in prog-mode."
    (interactive)
    (cl-loop for buf in (buffer-list)
             collect (with-current-buffer buf
                       (when (derived-mode-p 'prog-mode)
                         (display-line-numbers-mode -1))))
    (remove-hook 'prog-mode-hook 'winny--enable-line-numbers)
    (when (called-interactively-p 'interactive)
      (message "Line numbers DISABLED in prog-modes."))
    nil)

  (defun winny--enable-line-numbers ()
    "Internal hook function."
      (display-line-numbers-mode 1))

  (defun toggle-line-numbers ()
    "Toggle visibility of line numbers in prog-mode."
    (interactive)
    (if (member 'winny--enable-line-numbers prog-mode-hook)
      (call-interactively 'disable-line-numbers)
      (call-interactively 'enable-line-numbers)))

  (global-set-key (kbd "C-x M-l") 'toggle-line-numbers)
#+end_src

** Ace Jump
Type =C-c C-SPC= or =C-c SPC= then type the character you wish to navigate to.
Type the subsequent highlighted character when prompted.  Viola!

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :ensure t
    :config
    (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
    (define-key global-map (kbd "C-c C-SPC") 'ace-jump-mode))
#+end_src

* Editing
** Lisp editing

*** Edit s-expressions efficiently with Paredit
Paredit is the best.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :init
    (dolist (m '(emacs-lisp-mode-hook
                 racket-mode-hook
                 lisp-mode-hook
                 scheme-mode-hook
                 clojure-mode-hook))
      (add-hook m #'paredit-mode))
    (add-hook 'paredit-mode-hook
              (defun winny/add-paredit-keystrokes ()
                "Ensure custom keys are enabled in paredit."
                (bind-keys :map paredit-mode-map
                           ("{"   . paredit-open-curly)
                           ("}"   . paredit-close-curly))
                (unless terminal-frame
                  (bind-keys :map paredit-mode-map
                             ("M-[" . paredit-wrap-square)
                             ("M-{" . paredit-wrap-curly))))))
#+END_SRC

*** Make parenthesis stand out less in lisp modes

#+BEGIN_SRC emacs-lisp
(use-package paren-face
  :ensure t
  :config
  (setq paren-face-regexp (rx (any "()[]{}")))
  (add-to-list 'paren-face-modes 'racket-mode)
  (add-to-list 'paren-face-modes 'racket-reply-mode)
  (add-to-list 'paren-face-modes 'emacs-lisp-mode)
  (add-to-list 'paren-face-modes 'lisp-mode))
#+END_SRC

*** Tweak =if= to not indent weird in elisp
#+BEGIN_SRC emacs-lisp
(put 'if 'lisp-indent-function 'defun)
#+END_SRC
** Expand region
Use =C-== to select things around the point such as words, balanced delimiters,
paragraphs, functions, incrementally.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)))
#+END_SRC
** editorconfig support
Configure the editor via =.editorconfig= files.

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :config
  (setq editorconfig-mode-lighter " EdC")
  :init
  (editorconfig-mode 1))
#+END_SRC
** Electric parens
Insert matching parenthesis.

#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC
** Wider fill column
Use 79 chars in each line for filling.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 79)
#+END_SRC
** No tabs by default
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
** Use closest indent column for margin comments
#+begin_src emacs-lisp
  (setq-default comment-column 0)
#+end_src
** Zap
One can use =M-z= to character.  This will delete all text including the first
occurrence of the prompted character.  Sometimes this is not ideal, so one can
use =C-M-z= to zap up to (but keep) the prompted character.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-z") 'zap-up-to-char)
#+END_SRC
** Some helper macros/commands
#+BEGIN_SRC emacs-lisp
(defun winny/maybe-query-replace-bad-comma (no-prompt)
  "Replace occurrences of , followed by a non-space.  if `NO-PROMPT' then do don't do a query replace."
  (interactive "P")
  (funcall
   (if no-prompt
     'replace-regexp
     'query-replace-regexp)
   ",\\(\\S \\)"
   ", \\1"))
#+END_SRC

*** Collapse a wrapped paragraph to a single line.

This unwraps a paragraph into one line.

#+BEGIN_SRC emacs-lisp
(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
    logical line.  This is useful, e.g., for use with
    `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))
#+END_SRC

*** Delete whitespace right of point
#+BEGIN_SRC emacs-lisp
(defun winny/kill-whitespace-right ()
  "Kill whitespace to right of point."
  (interactive)
  (delete-region (point) (save-excursion (skip-chars-forward " \t") (point))))
#+END_SRC

*** Alternate function to mark functions
#+BEGIN_SRC emacs-lisp
(defun winny/mark-defun ()
  (interactive)
  (mark-defun)
  (when (or (comment-only-p (region-beginning) (region-end))
            (looking-at-p "[[:space:]]*$"))
    (forward-line 1)))
#+END_SRC

*** Quell Shellcheck at point
Create a line similar to =# shellcheck disable=SC1234= above the current line
in order to calm down Shellcheck.
#+begin_src emacs-lisp
  (fset 'winny/shellcheck-disable
     (kmacro-lambda-form [?\C-  ?\C-  ?\M-x ?f ?l ?y ?c ?h ?e ?c ?k ?- ?d ?i ?s ?p ?l ?a ?y ?- ?e ?r ?r ?o ?r ?- ?a ?t ?- ?p ?o ?i ?n ?t ?\C-m ?\C-h ?e ?\C-x ?o ?\M-> ?\C-p ?\C-s ?\[ ?\C-m ?\C-  ?\M-f ?\M-w ?q ?\C-a ?\C-o ?\C-i ?# ?  ?s ?h ?e ?l ?l ?c ?h ?e ?c ?k ?  ?d ?i ?s ?a ?b ?l ?e ?= ?\C-y ?\C-u ?\C-  ?\C-u ?\C- ] 0 "%d"))
  (add-hook 'sh-mode-hook
            (defun winny--bind-shellcheck-disable ()
              (global-set-key (kbd "C-c ! k") 'winny/shellcheck-disable)))
#+end_src
** Snippets
Using [[https://github.com/joaotavora/yasnippet][Yasnippets]].  See the [[http://joaotavora.github.io/yasnippet/][documentation]].

*** Yasnippets (core)
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :hook
    (snippet-mode . (lambda ()
                      ;; Do not force a newline in snippets.
                      (setq-local require-final-newline nil)))
    :init
    (make-directory (concat user-emacs-directory "/snippets") :parents)
    (yas-global-mode 1))
#+END_SRC
*** Upstream Snippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets
    :ensure t)
#+END_SRC
** Kill line or region
Type =C-w= without a region (selection) to kill the current line.  Found this
in [[https://www.masteringemacs.org/][Mastering Emacs]], a fantastic book that you should also read :).

#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :ensure t
    :init
    (whole-line-or-region-global-mode))
#+END_SRC
** Open file to previous position
#+begin_src emacs-lisp
  (save-place-mode 1)
#+end_src
* RSS Feed Reader

#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :ensure t
  ;; :after writeroom-mode
  ;; :hook (elfeed-show-mode . (lambda ()
  ;;               (writeroom-mode 1)
  ;;               (setq-local shr-width (writeroom--calculate-width))))
  )
#+END_SRC

Manage RSS feeds in [[file:elfeed.org][elfeed.org]].

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :ensure t
  :init
  (elfeed-org))
#+END_SRC
* Transmission

#+BEGIN_SRC emacs-lisp
  (use-package transmission
    :disabled
    :init
    (defun winny/transmission-add-magnet-uri ()
      "Add a magnet URI"
      (interactive)
      (transmission-add (read-string "Magnet URI: ")))
    :bind (:map transmission-mode-map
                ("A" . winny/transmission-add-magnet-uri)))
#+END_SRC
* Shebang improvements
** Make shebanged files executable on save
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
          (defun winny/make-shebanged-file-executable ()
            "Make sure scripts with shebang are saved with expected permissions."
            (interactive)
            (when (and (save-excursion (goto-char (point-min)) (looking-at "#!"))
                       (not (file-executable-p buffer-file-name)))
              (message "Making `%s' executable..." buffer-file-name)
              (executable-chmod))))
#+END_SRC
** Detect shebang change and change major mode
#+BEGIN_SRC emacs-lisp
(use-package shebang-change
  :init
  ;;(winny/add-shebang-change-hooks)
  )
#+END_SRC

* Mode line tweaks
(Besides smart-mode-line)
** Show battery when a battery is present
#+BEGIN_SRC emacs-lisp
  (display-battery-mode
   ;; Show battery status only if the system can use a battery.
   (if (and (fboundp 'battery-status-function)
            (lexical-let ((ac-line-status
                           (alist-get ?L (funcall battery-status-function))))
              (and ac-line-status (not (equal "N/A" ac-line-status)))))
     1
     -1))
#+END_SRC

** Bell
#+BEGIN_SRC emacs-lisp
  (use-package mode-line-bell
    :ensure t
    :init
    (mode-line-bell-mode 1))

  (setq visible-bell t)
#+END_SRC
* Buffer management

** Revert all buffers

#+BEGIN_SRC emacs-lisp
(defun revert-all-buffers ()
  "Refreshes all open buffers from their respective files."
  (interactive)
  (dolist (buffer (buffer-list) (message "Refreshed open files"))
    (let ((fn (buffer-file-name buffer)))
      (when (and fn (not (buffer-modified-p buffer)))
        (if (file-exists-p fn)
          (progn
            (set-buffer buffer)
            (revert-buffer t t t))
          (message "Backing file `%s' no longer exists! Skipping." fn))))))
#+END_SRC

** Kill buffers missing their files

#+BEGIN_SRC emacs-lisp
(defun kill-all-missing-buffers (no-ask)
  "Kill all buffers with missing files.

When prefix argument NO-ASK is non-nil, do not ask before killing
each buffer"
  (interactive "P")
  (dolist (buffer (buffer-list))
    (let ((fn (buffer-file-name buffer)))
      (when (and fn (not (file-exists-p fn)))
        (if no-ask
          (kill-buffer buffer)
          (kill-buffer-ask buffer))))))
#+END_SRC

** Copy the buffer filename
#+BEGIN_SRC emacs-lisp
  (defun yank-file-name (choice)
    "Copy the the buffer path to the `kill-ring'.
  CHOICE can be `?f', `?d', or `?n' for full path, directory path,
  or filename respectively.  Via
  https://stackoverflow.com/a/18814469/2720026"
    (interactive "cCopy Buffer Name (F) Full, (D) Directory, (N) Name, (P) Project Path")
    (let* ((name (if (eq major-mode 'dired-mode)
                   (dired-get-filename)
                   (buffer-file-name)))
           (s
            (cl-case choice
              (?f name)
              (?d (file-name-directory name))
              (?n (file-name-nondirectory name))
              (?p (replace-regexp-in-string (regexp-quote (projectile-project-root)) "" name)))))
      (cond
       (s
        (message "%s copied" s)
        (kill-new s))
       (t
        (message "(No name to copy.)")))))
#+END_SRC

** Show buffer filename is minibuffer

#+BEGIN_SRC emacs-lisp
(defun show-file-name ()
  "Show the full path file name in the minibuffer."
  (interactive)
  (message (buffer-file-name)))
#+END_SRC

** Use ibuffer
#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer)
#+END_SRC

* Highlight text
Better highlight.  Don't believe I use this?
#+BEGIN_SRC emacs-lisp
(use-package highlight
  :ensure t)
#+END_SRC

Highlight Todo's and XXX.
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure t
  :init
  (global-hl-todo-mode 1))
#+END_SRC

Highlight color codes.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t)
#+END_SRC

* Dashboard
Show a nice screen when emacs starts up or creates a new fram.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :bind (:map dashboard-mode-map
                ("p" . dashboard-previous-line)
                ("n" . dashboard-next-line))
    :init
    (setq ;;initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
          dashboard-items '((projects . 5)
                            (recents . 5)
                            (bookmarks . 5))
          dashboard-item-shortcuts '((projects . "j")
                                     (recents . "r")
                                     (bookmarks . "m")
                                     (agenda . "a")
                                     (registers . "e"))
          dashboard-image-banner-max-height 50
          dashboard-image-banner-max-width 50)

    ;; Add the hook to startup, but... See second line.
    (dashboard-setup-startup-hook)
    ;; Ensure scratch is hidden
    (add-hook 'emacs-startup-hook 'delete-other-windows)

    (defun dashboard ()
      "Switch to or create the dashboard. "
      (interactive)
      (let ((buffer "*dashboard*"))
        (when (not (get-buffer buffer))
          (dashboard-insert-startupify-lists))
        (switch-to-buffer buffer))))
#+END_SRC

* General keybinds

** Browse kill ring
#+BEGIN_SRC emacs-lisp
(use-package browse-kill-ring
  :ensure t
  :bind (("C-x y" . browse-kill-ring)))
#+END_SRC

** Compile shortcut

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x c") 'compile)
#+END_SRC

** Disable =C-z= when in windowed mode
I prefer the window manager to handle this, and it only feels familiar in
console, where C-z does exactly what it should.  It shouldn't minimize windows,
it's not the same thing.

#+BEGIN_SRC emacs-lisp
(when window-system
  (global-unset-key (kbd "C-z")))
#+END_SRC

** View register
Pretty nice to see what's in the registers.  Bind it to =C-x r v=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x r v") 'view-register)
#+END_SRC

** Backup key for =M-x= (=C-x M-x=)
Just in case the =M-x= replacement de-jure messes up, keep it bound elsewhere.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x M-x") 'execute-extended-command)
#+END_SRC

** Find thing at point
=C-c P f= to find file at point.  And =C-c P u= to find url at point.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-c P f") 'find-file-at-point)
(define-key global-map (kbd "C-c P u") 'browse-url-at-point)
#+END_SRC

** bury buffer
Like =kill-buffer= but just moves the buffer to the end of the buffer list.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x K") 'bury-buffer)
#+END_SRC

** Move macro keys
Default macro keys are in a weird place so let's move them over.  I had a
reason to do this, but I've since forgotten.

(Note, f3 is already rebound in a different section.  See [[Ergonomic search key][here]].  Menu-bar-open
(F10) default is not very useful -- just use =M-`=.)

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f9>") 'kmacro-start-macro-or-insert-counter)
(global-set-key (kbd "<f10>") 'kmacro-end-or-call-macro)
#+END_SRC

** Lazy repeat
Having to type the default repeat key is torture.  =C-x z= requires *four*
actions.  Hold down =C=, then type =x=.  Release =C=.  Type =z=.  So instead,
just Bind =C-x C-z= which means one can rapid-fire repeat with only two
keystrokes per repeat.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-z") 'repeat)
#+END_SRC

** Save =(yank)= to register
#+BEGIN_SRC emacs-lisp
  (defun winny/save-last-kill-to-register (register)
    "Save the last kill to register."
    (interactive (list (register-read-with-preview "Copy last kill to register: ")))
    (set-register register (current-kill 0)))
  (define-key global-map "\C-xr\C-y" 'winny/save-last-kill-to-register)
#+END_SRC

** Advent of Code quickstart

This creates a new directory for the advent of code day, then creates a
sample.txt buffer.  Finally it creates a =.rkt= source file for the day with a
template.

#+begin_src emacs-lisp
  (fset 'new-aoc-day
        (kmacro-lambda-form [?\C-x ?d ?~ ?p ?r ?o ?/ ?a ?o ?c ?/ ?2 ?0 ?2 ?1 ?/ return ?+ ?d ?a ?y ?\C-u ?\C-x ?q return return ?\C-x ?\C-f ?s ?a ?m ?p ?l ?e ?. ?t ?x ?t return ?\C-x ?3 ?\C-x ?\C-f return ?^ ?\C-  ?\C-e ?\M-w return ?\C-x ?\C-f ?d ?a ?y backspace backspace backspace ?\C-y ?. ?r ?k ?t return ?\M-x ?y ?a return return] 0 "%d"))
#+end_src

* Other packages / support stuff

** writeroom-mode
This improves the presentation of emacs so it's less distracting when writing
prose.  It centers the text, reduces paragraph width, and increases line
height.  It has application in other modes where reading content can be
improved by applying the aforementioned visual tweaks.

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :ensure t
    :init
    (setq writeroom-fullscreen-effect nil))
#+END_SRC

** projectile
Manage groups of buffers by project.  Also do actions with respect to a
project.  A project root can be defined as a git repository, a folder with a
=.projectfile= file in it, and so on.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :bind-keymap ("C-c p" . projectile-command-map)
  :config
  (setq projectile-mode-line-prefix " Pro")
  :init
  ;;(setq projectile-project-search-path '("~/pro" "~/code" "~/docs"))
  (setq projectile-project-search-path '("~/"))
  (projectile-mode 1))
#+END_SRC

** systemd
#+begin_src emacs-lisp
  (use-package systemd
    :ensure t)
#+end_src

** ansible
Helper stuff for ansible.

#+BEGIN_SRC emacs-lisp
(use-package ansible
  :ensure t)
#+END_SRC

Syntax highlight inventory files

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/inventory[^/]*\\'" . conf-unix-mode))
#+END_SRC

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t)
#+end_src

** vterm
#+BEGIN_SRC emacs-lisp
  ;; Tell vterm to automatically try to compile the module when it's not present.
  ;; This prevents vterm from prompting the user if they wish to compile and
  ;; delaying productivity.
  (setq vterm-always-compile-module t)

  (use-package vterm
    :ensure t
    :bind (("C-`" . vterm))
    :init
    (setq vterm-set-bold-hightbright t))
#+END_SRC
* Some other functions

** Helper function for creating new emacs frames
#+BEGIN_SRC emacs-lisp
(defun winny/raise-or-create-window-system-frame (display)
  "Raise an existing frame in the window system or create a new one.

DISPLAY is the X11 DISPLAY variable contents."
  (let ((frames (seq-filter #'(lambda (f) (frame-parameter f 'display)) (frame-list))))
    (if (null frames)
      (make-frame `((window-system . x)
                    (display . ,display)))
      (select-frame-set-input-focus (car frames)))))
#+END_SRC

** Helper to remove item from an alist
#+BEGIN_SRC emacs-lisp
(defun remove-from-list (list-var element)
  "Remove ELEMENT from LIST-VAR."
  (setq list-var (delete element list-var)))
#+END_SRC

** toggle word wrap
=M-x toggle-word-wrap RET=

#+BEGIN_SRC emacs-lisp
(defun toggle-word-wrap ()
  "Toggle word wrap."
  (interactive)
  (message (format
            "Word wrap %s."
            (if (setq word-wrap (not word-wrap))
              "enabled"
              "disabled"))))
#+END_SRC

** Change the mode line and reload the major mode
#+BEGIN_SRC emacs-lisp
(defun winny/change-prop-line-mode (mode &optional dont-change-mode)
  "Change the prop line's major MODE.
If DONT-CHANGE-MODE is not nil, dont change to that MODE first."
  (interactive "aMajor mode: \nP")
  (unless dont-change-mode
    (funcall-interactively mode))
  (delete-file-local-variable-prop-line 'mode)
  (let ((sans-mode (intern (replace-regexp-in-string "-mode$" "" (symbol-name mode)))))
    (add-file-local-variable-prop-line 'mode sans-mode nil)))
#+END_SRC

** Bind a key in the current buffer only
Great for experimenting with keyboard shortcuts.

#+BEGIN_SRC emacs-lisp
(defun buffer-local-set-key (key func)
  (interactive "KSet key on this buffer: \naCommand: ")
  (let ((name (format "%s-magic" (buffer-name))))
    (eval
     `(define-minor-mode ,(intern name)
        "Automagically built minor mode to define buffer-local keys."))
    (let* ((mapname (format "%s-map" name))
           (map (intern mapname)))
      (unless (boundp (intern mapname))
        (set map (make-sparse-keymap)))
      (eval
       `(define-key ,map ,key func)))
    (funcall (intern name) t)))
#+END_SRC

** Find the current buffer as root
#+BEGIN_SRC emacs-lisp
  (defun winny/find-current-buffer-as-root ()
    "Find the current buffer as root using TRAMP sudo."
    (interactive)
    (when (file-remote-p default-directory)
      (error "Already a TRAMP buffer.  Giving up"))
    (let ((path (expand-file-name
                 (if (eq major-mode 'dired-mode)
                   default-directory       ; Dired does not use buffer-file-name to represent a path
                   buffer-file-name))))
      (find-alternate-file (concat "/sudo:root@localhost:" path))))
#+END_SRC

** Hide fringes
#+BEGIN_SRC emacs-lisp
  (defun hide-fringes ()
    "Hide fringes"
    (interactive)
    (set-window-fringes (selected-window) 0 0))
#+END_SRC

** Change default directory

#+begin_src emacs-lisp
  (defun change-default-directory (target)
    "Change DEFAULT-DIRECTORY to TARGET.

  Useful for things like vterm, ansi-term, or term.  One can change
  directory in the child shell but it won't reflect in Emacs.  This
  allows the user to manually update this."
    (interactive "D")
    (setq default-directory target))
#+end_src

* Narrow
Enable =narrow-to-region=
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

* Emacs daemon/server quick keys
Like =with-editor=, set up =server.el= (see =server-visit-files=) with =C-c
C-c= to "commit" save and close the buffer, and =C-c C-k= to revert and close
the buffer (thereby discarding the edits).

#+begin_src emacs-lisp
  (add-hook 'server-visit-hook
            (defun winny/server-visit-hook ()
              (when (frame-parameter nil 'winny/opened-from-editor)
                (buffer-local-set-key (kbd "C-c C-c") (defun winny/server-edit-commit ()
                                                        (interactive)
                                                        (save-buffer)
                                                        (server-edit)))
                (buffer-local-set-key (kbd "C-c C-k") (defun winny/server-edit-abort ()
                                                        (interactive)
                                                        (revert-buffer nil t)
                                                        (server-edit))))))
#+end_src

* Load =host-post-init.el=
#+BEGIN_SRC emacs-lisp
  (winny/load-file-when-present "~/.emacs.d/host-post-init.el")
#+END_SRC

(And load the legacy =host.el= for now...)

#+BEGIN_SRC emacs-lisp
  (winny/load-file-when-present "~/.emacs.d/host.el")
#+END_SRC

* Indication of completion
#+BEGIN_SRC emacs-lisp
(message "configuration.org evaluation complete.")
#+END_SRC
